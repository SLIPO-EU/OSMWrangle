URI:                                     ##SLIPO-specific constraint: Specifies a URI of each POI; If needed, extra attribute "DATA_SOURCE" is used for constructing these URIs                
  entity: uri
  generateWith: getUUID(DATA_SOURCE,osm_id)    ## getUUID(osm_id)     ## keepOriginalID(osm_id)     ##getRandomUUID   ##Function call to generate URI
osm_id:
  partOf: sourceInfo
  entity: source
  predicate: slipo:poiRef
DATA_SOURCE:                      ##SLIPO-specific constraint: Specifies the data source provider of each POI; Assuming that extra attribute "DATA_SOURCE" generated by TripleGeo is always used for constructing the URIs for data sources
  partOf: sourceInfo
  entity: source
  predicate: slipo:sourceRef
  generateWith: getDataSource     ##Function call to fill-in this value that does NOT exist in the original dataset
Category:                         ##Apply SLIPO-specific constraint: Specifies the URI for the category assigned to each POI; Assuming that extra attribute "CATEGORY_URI" generated by TripleGeo is always used for constructing the URIs for categories
  entity: category
  predicate: slipo:category
  datatype: uri
phone:
  instanceOf: contact
  entity: phone
  predicate: slipo:phone
  type: phone
"contact:phone":
  instanceOf: contact
  entity: phone
  predicate: slipo:phone
  type: phone  
email:
  instanceOf: contact
  entity: email
  predicate: slipo:email
  type: email
"contact:email":
  instanceOf: contact
  entity: email
  predicate: slipo:email
  type: email  
fax:
  instanceOf: contact
  entity: fax
  predicate: slipo:fax
  type: fax  
"contact:fax":
  instanceOf: contact
  entity: fax
  predicate: slipo:fax
  type: fax   
website:
  entity: homepage
  predicate: slipo:homepage
  datatype: uri
"contact:website":
  entity: homepage
  predicate: slipo:homepage
  datatype: uri
url:
  entity: homepage
  predicate: slipo:homepage
  datatype: uri  
name:
  instanceOf: name
  entity: name
  predicate: slipo:name
  type: official
"name:%LANG":                       ##Specification for multi-faceted attribute values (i.e., names in multiple languages)
  instanceOf: name
  entity: name
  predicate: slipo:name
  type: NONE                      ##Instructs NOT to issue triples regarding resource type
  language: getLanguage           ##Function call that is invoked at runtime to extract the language tag from the attribute name
int_name:
  instanceOf: name
  entity: int_name
  predicate: slipo:name
  type: international
  language: en  
alt_name:
  instanceOf: name
  entity: alt_name
  predicate: slipo:name
  type: alternative   
"addr:street":
  partOf: address
  entity: address
  predicate: slipo:street
"addr:housenumber":
  partOf: address
  entity: address
  predicate: slipo:number
"addr:city":
  partOf: address
  entity: address
  predicate: slipo:locality
"addr:country":
  partOf: address
  entity: address
  predicate: slipo:country 
"addr:postcode":
  partOf: address
  entity: address
  predicate: slipo:postcode  
postal_code:
  partOf: address
  entity: address
  predicate: slipo:postcode 
"contact:postcode":
  partOf: address
  entity: address
  predicate: slipo:postcode   
opening_hours:
  partOf: timeSlot                ##Work-around for SLIPO ontology: This must be actually specified as an instance of the TimeSlot entity.
  entity: openingHours
  predicate: slipo:concat  
LONGITUDE:
  entity: lon
  predicate: wgs84_pos:long
  datatype: float
  generateWith: geometry.getLongitude           ##Function call to fill-in this value that does NOT exist in the original dataset
LATITUDE:
  entity: lat
  predicate: wgs84_pos:lat
  datatype: float
  generateWith: geometry.getLatitude            ##Function call to fill-in this value that does NOT exist in the original dataset  
AREA:                                           ##Auto-generated attribute (NOT existing in the original data) based on geometry
  entity: area
  predicate: slipo:area
  datatype: float  
  generateWith: geometry.getArea                ##Function call to fill-in this value that does NOT exist in the original dataset
LENGTH:                                         ##Auto-generated attribute (NOT existing in the original data) based on geometry
  entity: length
  predicate: slipo:length
  datatype: float  
  generateWith: geometry.getLength              ##Function call to fill-in this value that does NOT exist in the original dataset
TRANSLIT:
  instanceOf: name
  entity: translit_name
  predicate: slipo:name
  type: transliterated
  language: en
  generateWith: getTransliteration(name)         ##Function call to fill-in this value that does NOT exist in the original dataset    